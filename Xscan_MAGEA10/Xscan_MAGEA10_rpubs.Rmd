---
title: "Computing T-cell receptor recognition motifs and their matches in the human proteome"
author: "Thomas Weissensteiner"
date: "2024-09-15"
output:
  html_document:
    code_folding: show
    toc: true
    toc_float: true
    toc_depth: 5
---
**My scripts:**  

* rendered html versions: [Rpubs/thomas-weissensteiner](https://rpubs.com/thomas-weissensteiner)  
* .rmd files with executable code chunks: www.github.com/thomas-weissensteiner/portfolio/tree/main/  

**About myself:** www.linkedin.com/in/ThomasWs-Mopfair

<br> 
```{r Options, include = FALSE}
## Global directory and output options 

# The working directory in "Global directory and output options" needs to be customised, and should include the following additional files:
# "                                         .csv", the example data file

# "Summarizing_Human_Phenotype_Ontology_Terms_figs", a folder containing additional figures not generated by the code chunks  

knitr::opts_knit$set(root.dir = "C:/Users/ThomasWeissensteiner/OneDrive/Documents/portfolio/MAGEA10_paper")
setwd("C:/Users/ThomasWeissensteiner/OneDrive/Documents/portfolio/MAGEA10_paper")

# knitr::opts_knit$set(root.dir = "/mnt/chromeos/GoogleDrive/MyDrive/MAGEA10_paper")
knitr::opts_chunk$set (warning = FALSE)
knitr::opts_chunk$set (tidy = FALSE)
knitr::opts_chunk$set (attr.output='style="max-height: 100px;"')

# R package for rendering tables in HTML format (kableExtra rather than kable is required for R 4.3.0)

library(kableExtra)
```
<br>
<br>  

### 1. Background 
<br>

#### 1.1. Motivation 
<br>
  
Adoptive transfer of T-cells which recognise and kill cells expressing tumor antigens is an emerging anti-cancer therapy. The cancer-killing potency of naturally occurring T-cells is generally low. Therefore, a promising strategy has been to equip them with a T-cell receptor (TCR) that has been genetically engineered to bind cancer-expressed antigens with high affinity. However, this manipulation also risks generating reactivity to antigens expressed by normal tissue, causing serious adverse events. Importantly, _in-vitro_ assays and testing in animal models did not always detect such cross-reactivity due to cell culture and species-specific differences in the antigenic repertoire ^1^.  

To mitigate the risk of off-target toxicities in future clinical trials, Adaptimmune developed an extensive _in-vitro_ testing pipeline. A pivotal element was predicting the repertoire of peptides in the human proteome that cytotoxic T-cells with a candidate TCR might respond to ^2^.  
Peptides of 9 amino-acids length are by far the largest category, whereas shorter or longer ones are much less likely to be recognised. However, even for a 9-mer peptide alone, the experimental testing of all possible combinations of natural amino-acids at all positions would be impractical (9^20^ variants). Therefore, the repertoire of potentially recognised peptides was inferred by a combined _in-vitro_ / _in-silico_ approach:  

1. _In-vitro_ assays were performed with peptides carrying sequential substitutions at each individual position (9 x 20 variants)  

2. Single amino-acid substitutions for which T-cell responses exceeded a certain threshold (expressed as percentage of response to the target, or index peptide) were defined as "tolerated"  

3. A table of tolerated amino-acid substitutions at each position of the 9-mer peptide was constructed (X-scan motif), and the human proteome searched for matches with all of its permutations. The results were treated as potential targets for T-cell reactivity against normal tissue, requiring further investigation

This strategy was implemented for prioritizing a candidate TCR for further extensive pre-clinical and clinical testing ^3-5^. Notably, the X-scan method allowed to discriminate between two TCRs which appeared to be equally optimal in conventional biochemical and cellular assays ^2^.  

Subsequently, at least 6 other studies have used the same method but no code was made available in any of the publications ^2,3,6-10^. I set myself a challenge to reproduce the X-scan results in Figures 5 and 6 of our paper ^2^. The task included evaluating matches in the human proteome for > 10 million peptide sequences, under 126 different conditions.  
<br>
<br>  

#### 1.2. Workflow overview
<br>

The following steps were chosen:  

1. Manual scanning of the published barchart to generate a table of _in-vitro_ T-cell responses against the index peptide and its single amino-acid substitution variants

2. Calculating the ratios of responses to variants vs. responses to the index peptide, and their confidence intervals

3. Generating a list of permutation matrices for amino-acid substitutions tolerated by the two candidate TCRs at different cut-offs of the variant/index response ratio  

4. a. Generating a table for the canonical X-scan motif, displaying its amino-acids and their properties (corresponding to Fig. 5B and C in ref. ^2^)  

   b. Plotting X-scan motif sizes against cut-offs for comparing the specificity of the two TCRs across variant/index response ratios 
   
   c. Computing a non-redundant set of amino-acid sequences that represents all 9-mer peptides that are potentially recognised by one or both of the two TCRs at any threshold
   
5. Searching the human proteome for matches with the peptide sequences generated in 4c   

6. Combining the search results with permutation matrices generated in step 3 to filter out proteome matches for each TCR at different response cut-off levels (plot corresponding to Fig. 6A in ref. ^2^)  

7. Combining results of steps 6 and 4b (alternative visualisation to Fig. 6B in ref. ^2^)  
<br>
<br>  

### 2. Code and results
<br>

#### 2.1. Required R packages and data
<br>

TCRs c765 and c796 were genetically engineered to recognise the peptide GLYDGMEHL ("index peptide") when presented by the human lymphocyte antigen (HLA) allele A*02:01. A total of 180 peptides, representing the index and all of its natural amino-acid single substitution variants, were tested experimentally for their ability to stimulate TCR c765 or TCR c796 transduced T-cells (interferon-gamma spot count).  

Because the original raw data were unavailable for this analysis, I scanned the barchart figure S2 in ref. ^2^ using PlotDigitizer ^11^.
<br>
```{r Chunk_1, message = FALSE, results = "hide"}
# -- Chunk 1                                     -- #

## Load required R libraries and data

# Libraries, package versions, and functions used when writing the script

library(dplyr)        # version 1.1.4  # general grammar
library(purrr)        # version 1.0.2  # set_names, reduce, list_rbind
library(tidyr)        # version 1.3.1  # pivot_longer, pivot_wider
library(tibble)       # version 3.2.1  # tibble, as_tibble, column_to_rownames
library(biomartr)     # version 1.0.7  # getProteome, read_proteome
library(Biostrings)   # version 2.68.0 # vmatchPattern
library(parallel)     # part of R4.3.3 # parallel processing
library(progress)     # version 1.2.3  # monitoring progress of proteome searches
library(ggplot2)      # version 3.5.1  # plots


# Human proteome data (NCBI RefSeq, release date 2022-02-03, accessed on 10/09/24)

HS.proteome.refseq <- 
  getProteome( 
    db = "refseq", organism = "Homo sapiens",
    gunzip = FALSE,
    path = file.path("_ncbi_downloads","proteomes")
    )

human_proteome <- 
  read_proteome( file = HS.proteome.refseq)


# T-cell response data (tab-delimited .csv document)

Xscan <- 
  read.delim ("https://raw.githubusercontent.com/thomas-weissensteiner/portfolio/main/Xscan_MAGEA10/Xscan_c796c756.csv")

Xscan
```
<br>

**_Experimental T-cell response data._**   
_In the column names, "position" means amino-acid position in the 9-mer peptide, "aa": amino-acid (one letter code), "count": interferon gamma spot count (~ number of responding T-cells), "SE": standard error of the mean, "index": an amino-acid of the index peptide if the value is "1"._
<!--  --> <hr>
<br>
<br>

##### 2.2. Generation of permutation matrices that define potentially recognised peptides for different cut-offs of the T-cell response
<br>

The original study used the ranges of count ratios obtained from triplicate experiments for computing the X-scan motifs. However, only the means and their standard errors (SE) were reported. When setting out to replicate the figures with the published data, I therefore decided to use 95% confidence intervals (CIs) instead.  
Although CIs are wider than SEs, they ought to be well suited here for two reasons. Firstly, we should be concerned about the ranges of responses rather than the precision of their means (SE). Secondly, CIs allow for easy error propagation when transforming counts to count ratios, and eventually to probabilities for peptide matches in the human genome.
<br>
```{r Chunk_2, dependson: Chunk_1}
# -- Chunk 2                                     -- #
# -- Requires object generated by chunk 1: Xscan -- #


## Data cleaning and transformation

# Replace all NAs with 0s

Xscan <- 
  Xscan %>% 
  replace(is.na(.), 0)

# Convert T-cell response counts + SE to counts +/- 95% CI

Xscan <- 
  Xscan %>%
  mutate(
    c796count_CI = (c796count_SE - c796count) * 1.96, 
    c756count_CI = (c756count_SE - c756count) * 1.96
    ) %>% 
  mutate(
    c796count_CIlow  = c796count - c796count_CI, 
    c796count_CIhigh = c796count + c796count_CI,
    c756count_CIlow  = c756count - c756count_CI, 
    c756count_CIhigh = c756count + c756count_CI
    ) %>% 
  select(
    aa_position, aa, 
    c796count, c796count_CIlow, c796count_CIhigh,
    c756count, c756count_CIlow, c756count_CIhigh,
    Index
    )

# Filter counts for responses to the index peptide

indexCounts <- Xscan %>% 
  filter (Index == 1) %>% 
  .[1, 
    c("c796count", "c796count_CIlow", "c796count_CIhigh", 
      "c756count", "c756count_CIlow", "c756count_CIhigh") ] 

# Generate a dataframe of T-cell response values divided by the response to the index peptide

Xscan_norm <- Xscan %>% 
  mutate(
    c796        = c796count/indexCounts$c796count,
    c796_CIlow  =  c796count_CIlow/ indexCounts$c796count_CIhigh,
    c796_CIhigh =  c796count_CIhigh/ indexCounts$c796count_CIlow,  
    c756        = c756count/indexCounts$c796count,
    c756_CIlow  =  c756count_CIlow/ indexCounts$c796count_CIhigh,
    c756_CIhigh =  c756count_CIhigh/ indexCounts$c796count_CIlow 
    ) %>% 
  select(
    aa_position, aa,
    c796, c796_CIlow, c796_CIhigh,  
    c756, c756_CIlow, c756_CIhigh
    ) 


## Generate logical tables of amino-acid substitutions that are tolerated at various fractions of the response to the index peptide

cut_off <- seq(0.02, 0.4, 0.02) 

Xmotifs_list <- 
  lapply (cut_off, 
    function (x) {

# Categorise response ratios according to being equal or greater than each cut-off value
    Xscan_norm %>% 
      mutate(
        across (!c(aa, aa_position), ~. >= x )) %>%
        
# Convert logical values to binary numbers:
      mutate(
        across (!c(aa, aa_position), ~+.))         
    } 
  ) %>% 
  set_names( cut_off)

```
<br>
<br>

#### 2.2. Canonical X-scan motifs of TCRs c796 and c756: amino-acids and their properties 
<br>

The canonical X-scan motif comprises all permutations of single amino-acid substitutions that are tolerated at 10% of the response generated by the index peptide. The product of the numbers of tolerated residues at each position is the size of the X-scan motif, equivalent to the number of peptide sequences that are potentially recognised by a TCR.  
This estimate discounts compensatory, additive or synergistic effects that might arise from interactions between several amino-acid substitutions. Predicting such effects is an ongoing topic of research. However, it can be argued that a TCR with a small motif size is likely to have greater specificity than a TCR with a large one. 

The following code chunk generates a table of amino acids and their properties for comparing the canonical X-scan motifs of the two TCRs.

<br>
```{r Chunk_3, dependson: Chunk_2, results= 'hold'}
# -- Requires object generated by chunk 2: Xmotifs_list -- #

## Plot details for amino-acids  (X-scan motif, ref.2)

# Generate a table of amino acid variants tolerated with a 10% cut-off for variant/index response
Fig5_aas <-  
  Xmotifs_list$"0.1" %>% 
    select(
      aa_position, aa, c796, c756) %>% 
    pivot_longer(
      cols = c(c796, c756), 
      names_to = "TCR"
      ) %>%
    pivot_wider(
      names_from = c(aa_position), 
      values_from = value
      ) %>% 
    mutate(
      across (c(p1, p2, p3, p4, p5, p6, p7, p8, p9), 
      ~ ifelse( . == 1, aa, "") ) 
      ) %>% 
       
  # Add a column for amino-acid properties 
    mutate(
      aa_property = aa, .before = aa
      ) %>% 
    mutate(
      aa_property = case_when (
        aa_property %in% c("D", "E")                ~ "Negative charge",
        aa_property %in% c("H", "K", "R")           ~ "Positive charge",
        aa_property %in% c("N", "Q", "S", "T", "C") ~ "Polar",
        aa_property %in% c("A", "G", "P")           ~ "Small, non-polar",
        aa_property %in% c("Y", "W", "F")           ~ "Aromatic, uncharged",
        aa_property %in% c("M", "L", "V", "I")      ~ "Alipathic"
      ) %>% 
      factor(
        levels = c("Negative charge", "Positive charge", "Polar", 
                "Small, non-polar", "Aromatic, uncharged", "Alipathic") 
      )
    ) %>% 
  select (!aa) %>% 
  group_by( aa_property, TCR) %>%
    summarise( 
      across(c(p1, p2, p3, p4, p5, p6, p7, p8, p9), 
      function (x) paste( unique(x[x != ""]), collapse = ", ") ), 
      .groups = 'drop'
      )

# For each position, calculate the total of all tolerated amino-acids
Fig5_sums <- 
  Xmotifs_list$"0.1" %>%         
  select( c(aa_position, aa, c756, c796)) %>% 
  group_by( aa_position) %>% 
  summarise( c756 = sum(c756),
             c796 = sum(c796)
             ) %>% 
  pivot_longer( 
    cols = c(c756, c796), 
    names_to = "TCR"
    ) %>% 
  arrange("TCR") %>% 
  pivot_wider( 
    names_from = c(aa_position), 
    values_from = value
    ) %>% 
  {cbind (aa_property = c("Total", "Total"), .)}

# Show results (optional: add formatting for html display)
rbind( Fig5_aas, Fig5_sums) %>% 
  data.frame() %>% 
  kable("html") %>% 
  kable_styling( 
    bootstrap_options = c("striped", "condensed", "responsive") 
    ) %>%     
  row_spec( c(13,14), bold = T)

```
<br>

This table is in agreement with Figure 5 ^2^ which I generated for the publication in Excel: 
<br>
![](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6343776/bin/koni-08-02-1532759-g005.jpg)
<br>
<br>
**_Amino-acid substitutions tolerated by TCRs c756 and c796 (canonical X-scan motif)._**  
_aa_property: amino-acid property; TCR: T-cell receptor; p1-9: amino-acid positions in the 9-mer peptide._  
**_Published figure:_** _\(A) Pie areas are proportional to the number of tolerated amino-acids, including the index. Pie segments represent a breakdown of tolerated amino-acids into groups with similar physico-chemical properties ^12^. The area within the outer circle corresponds to all 20 amino-acids being tolerated at a 10% threshold; the circle color indicates the property of the index peptide. \(B) Comparison of the X-scan search motifs for c756 and c796 at a response threshold of 10%. \(C) Total number of tolerated residues at each peptide position, including the index. The number of residues that would be identified as potentially tolerated by an alanine scan is shown for comparison._
<!--  --> <hr>
<br>
<br>

#### 2.3. TCR c796 has smaller X-scan motif sizes than TCR c756 at all response cut-offs, suggesting higher specificity  
<br>
The canonical X-scan motif considers amino-acid substitutions as "tolerated" when the mutant peptides elicit _in-vitro_  responses of at least 10% of that of the index. However, the thresholds for clinically relevant T-cell reactivity against different tissues _in-vivo_ are unknown. Therefore, I suggested to compare the specificity of the two TCRs candidates over a range of cut-off values.
<br>

```{r Chunk_4, dependson: Chunk_2, message = FALSE}
# -- Chunk 4                                             -- #  
# -- Requires objects generated in chunk 2: Xmotifs_list -- #  


## Plot dependence of X-scan motif size on response cut-off

# Generate a dataframe of X-scan motif sizes for each TCR (column) and cut-off value (row)
Xmotif_sizes <- 
  Xmotifs_list %>% 
    lapply( 
      function(x) {
        x %>% 
        group_by(aa_position) %>% 
        summarise (
          across (where (is.numeric), ~ sum(.))
          ) %>%
        select (!aa_position)
        }
      )

Xmotif_sizes <- 
  Xmotif_sizes %>% 
    lapply (
      function (x) apply (x, 2, prod)) %>% 
    cbind.data.frame()

# Generate a log scale with unlabeled minor breaks
ymin_log10 <-  
  min(Xmotif_sizes) %>% 
  log10() %>% 
  as.integer() - 1
ymax_log10  <- 
  max(Xmotif_sizes) %>% 
  log10() %>% 
  as.integer() + 1

breaks <- 
  10^c(ymin_log10:ymax_log10)
minor_breaks <- 
  rep( 1:9, ymax_log10 - ymin_log10 + 1)*
    (10^rep (ymin_log10:ymax_log10, each = 9) 
    )

# Re-arrange table of motif sizes
Xmotif_sizes %>% 
  rownames_to_column ("TCR") %>% 
  separate(
    TCR, into = c("TCR", "CI"), sep = "_", fill = "right"
    ) %>%
  mutate(
    CI = ifelse(is.na(CI), "Mean", CI)
    ) %>% 
  pivot_longer(
    cols = -c(TCR, CI),
    names_to = "cut_off",
    values_to = "motif_size"
    ) %>% 
  pivot_wider(
    names_from = CI,
    values_from = motif_size
    ) %>%

# Plot X-scan motif sizes vs. cut-off values
  ggplot(
    aes(
      x = cut_off, y = Mean, 
      group = TCR, color = TCR, fill = TCR)
    ) +
    geom_line() +
    geom_ribbon(
      aes(
        ymin = CIlow, ymax = CIhigh), 
      linetype = 0, alpha = 0.3
    ) +
    scale_colour_manual(
      values = c(c756 = "#435daf", c796 = "#e53935")
      ) +
    scale_fill_manual(
      values = c(c756 = "#435daf", c796 = "#e53935")
      ) +
    scale_y_log10(
      breaks = breaks, minor_breaks = minor_breaks
      ) + 
     annotation_logticks(sides = "l") +
      scale_x_discrete(
        breaks = seq(0, 0.4, by = 0.1), 
        labels = seq(0, 0.4, by = 0.1)
        ) +
    geom_vline(
      aes( xintercept = as.numeric (
        factor (0.1, levels = levels (as.factor(cut_off)))
        ),
      linetype = "Cut-off of the \ncanonical \nX-scan motif"), 
      col = "#00838f", lwd = 1.3, alpha = 0.3
      ) +
    labs(linetype = NULL) +
    xlab("Response cut-off") + 
    ylab("X-scan motif size (number of peptides)") +
    theme_minimal () + 
    theme(
      axis.line = element_line(color = "darkgrey"),
      axis.ticks = element_line(color = "black"),
      axis.ticks.length = unit(0.2, "cm")
    )

```
<br>
**_Numbers of peptides which are potentially recognised by the two candidate TCRs, at different cut-offs for the T-cell response._**  
_Coloured lines represent the X-scan motif sizes based on the mean response to peptides with single amino-acid substitutions. Shaded areas indicate the 95% CIs. Blue: TCR c756, red: TCR c796. The cyan vertical line marks the cut-off used to define the canonical X-scan motifs._  
<!--  --> <hr>
<br>

The plot confirms that TCR c796 had higher specificity than TCR c756 at all cut-off values. Differences in the size of the X-scan motifs became significant when amino-acid substitutions generating responses ≤ 12% of responses to the index were included. At the 10% cut-off for the canonical X-scan motif TCR c756 is predicted to recognise ~ 10x the number of peptides recognised by TCR c796. 
<br>
<br>

#### 2.4. Searching for peptides in the human genome that match the X-scan motif and are potential causes for T-cell responses against healthy tissue  
<br>
It was highly likely that a vast majority of peptides from the X-scan motifs would not be expressed by human tissues. For a clinically more meaningful comparison of TCR specificity, we therefore looked for matching sequences in the human proteome.  
In order to reproduce figure 6 of the published paper ^2^, 126 different sets of proteome matches had to be generated (2 TCRs, 3 summary statistics, 21 cut-offs). To avoid time-consuming redundant searches, I decided to first generate a set of unique peptides from the combined permutations of the two largest X-scan motifs. This set included all other sets that had to be analysed. I then computed results for the smaller sets by multiplying their permutation matrices with a similarly formatted matrix derived from the proteome matches, as outlined below. 
<br>

```{r Chunk_5, dependson: Chunk_2, message = FALSE}
# -- Chunk 5                                             -- #
# -- Required objects generated in chunk 2: Xmotifs_list -- #

## Generate a non-redundant set of potentially tolerated peptides from the combined permutations of the largest X-scan motifs of both TCRs

Xmotif_max <- 
  Xmotifs_list %>% 
  .[[min(names(.))]] %>% 
  select(
    aa_position, aa, c756_CIhigh, c796_CIhigh
    ) %>% 
  pivot_longer(
    c(c756_CIhigh, c796_CIhigh), 
    names_to = "TCR"
    ) %>% 
  split( .$TCR) %>% 
  lapply( 
    function (df) 
      pivot_wider(
        df, 
        names_from = "aa_position", 
        values_from = value
        ) 
      ) %>% 
    lapply (
      function (df) 
        apply(df, 2, 
          function(x) df$aa[x>0]
          ) %>% 
    .[setdiff(names(.), c("TCR", "aa"))]
    ) %>% 
  lapply(
    function (df) expand.grid(df, stringsAsFactors = F) ) %>% 
  {full_join(.[[1]], .[[2]])}

```

The next step implemented parallel processing. With an optimal number of cores, this decreased computing time to 1/4 compared to time required for normal serial processing (s. Appendix for details).  
Be warned that running this chunk on an ordinary PC still took several days. Accidental interruptions of the program during this time could have caused a very annoying loss of results. Therefore, I implemented a loop that can back up interim results at chosen intervals. In addition, this loop served as a coarse-step monitor for progress of the parallel computing, which did not seem easy to implement otherwise. There was a comparatively very small increase in computing time for each iteration of the loop, but I considered it a price worth paying. If you do not agree, simply set n <- 1 in the script below. 

```{r Chunk_6, dependson: Chunk_5, message = FALSE, eval = FALSE}
# -- Chunk 6                                             -- #
# -- Required objects generated in chunk 5: Xmotifs_list -- # 

## Perform search in n chunks and backup intermediate results (search may take several days on a PC, even with parallel processing) 

# Function for performing (human) proteome searches with X-scan motifs
# Input: dataframe of amino-acids in the different positions (columns) of each peptide (rows)
# Output: list of the number of matches (value) for each peptide found in the proteome, shown by its row index in the input file (name)
  
findMatches <- 
  function (Xmotif, ome = human_proteome) {
    pep <- 
      paste(Xmotif, collapse = "")
    pepMatch <- 
      vmatchPattern (pep, ome) %>% elementNROWS() %>% sum
    if( pepMatch > 0) { 
        pepMatch <- c(pepMatch, rownames(Xmotif)) 
        return( pepMatch)
      } 
    }

# Set up PC (Windows OS) for parallel processing of peptide searches in the human proteome
# Make sure to turn off automatic "sleep" in your PC's settings

# See appendix for determination of the optimal number of cores
cl <- makeCluster(12)

clusterExport(
  cl, 
  c("human_proteome", "Xmotif_max", "findMatches")
  )

clusterEvalQ(
  cl,
  {library(dplyr)
   library(purrr)
   library(Biostrings)
   } 
  )

# Set up a sub-directory for backing up partial search results
dir.create(
  file.path( paste(getwd()), paste( "Xmotif_matches") )
  )

# Determine number of times partial search results will be saved (nrow(Xmotif_max)/n must be an integer!)
n <- 160

# Initialise progress bar and list of search results
pb <- 
  progress_bar$new(
    format = "[Estimated time: elapsed > :elapsedfull, remaining < :eta]",
    total = n,
    clear = F,        # don't clear bar when finished
    )

# Loop through proteome searches with sequential subsets of the combined maximum X-scan motif, backup cumulative results
Xmotif_matches <- list()

for (i in 1:n) {
  Xmotif_matches [[i]] <- 
    Xmotif_max %>%  
    .[( (i-1)*nrow(.)/n + 1 ) : (i*nrow(.)/n), ] %>% 
    parApply(cl, ., 1, findMatches) %>% unlist 
    write.csv(
      Xmotif_matches %>% unlist,             
      "./Xmotif_matches/Xmotif_matches.csv")
    pb$tick()
  }


# Reset to serial processing
stopCluster(cl)


Xmotif_matches <- 
  Xmotif_matches %>% unlist

```
<br>
<br>

#### 2.5. Computing peptide matches
<br>

##### 2.5.1. Transformation of matching peptide sequences into a (0,1) matrix of the same format as the X-scan permutation matrices from chunk 2 {.tabset .tabset-fade}
<br>
Having retrieved the proteome matches for the combined maximum peptide set, the next task was to filter the results for the peptides of individual X-scan motifs. 
The most straightforward and intuitive approach might seem to generate the 126 sets of peptide sequences from the permutations of each motif, followed by looking for overlap with the maximum set. I felt that the same could be achieved more efficiently through multiplying the numerical values of the (0,1) permutation matrices with the numbers of proteome matches.  
<br>
<div>
```{r Chunk_7, dependson: Chunk_6, message = FALSE, results= "asis"}
# -- Chunk 7                                                           -- #
# -- Required objects generated in chunk 2: Xmotifs_list                -- # 
# -- Required objects generated in chunk 6: Xmotif_max, Xmotifs_matches -- #


# Alternatively, download proteome search results from GitHub:

Xmotif_matches <- 
  read.csv(
    "https://raw.githubusercontent.com/thomas-weissensteiner/portfolio/main/Xscan_MAGEA10/Xmotif_matches_c756c796_max.csv") %>% 
  deframe()

## Extract table of amino-acids from Xmotif_max for peptides with human proteome matches, and join it with Xmotif_matches

matches_index <- 
  Xmotif_matches %>% 
  names %>% as.numeric()

Xmotif_matches <- 
  full_join( 
    Xmotif_max[matches_index, ] %>% 
      cbind( matches_index = rownames(.),. ),
    Xmotif_matches %>% cbind.data.frame() %>% 
      cbind( matches_index = rownames(.),. ) %>% 
      set_names( "matches_index", "pep_matches")
    ) %>% 
  select(!matches_index)

# -- Optional: show table before reformatting in rendered html document -- #
Before <- 
  Xmotif_matches %>% 
  kable(., 200, format = "html") %>%
  kable_styling(full_width = FALSE) %>%
  scroll_box(height = "200px")
# ------------------------------------------------------------------------ #

##  Wrangle Xmotif_matches into a dataframe of  the same format as the dataframes in Xmotifs_list

# Reformat table and show results
Xmotif_matches <- 
  Xmotif_matches  %>%     

  # Collapse tolerated amino-acids to generate peptide names
  rowwise() %>% 
    mutate( 
      peptide = paste( c_across(!pep_matches), collapse = "")
      ) %>% 

# Pivot amino-acid positions to column "aa_position" and their values into a new column "aa" for amino-acids
  pivot_longer(
    cols = !c(peptide, pep_matches), 
    names_to = "aa_position", 
    values_to = "aa"
    ) %>%
  pivot_wider(
    names_from = !c(peptide, aa), 
    values_from = pep_matches
    ) %>% 
  split(.$peptide) %>% 
    map (., function (x) 
      pivot_longer(
        x, 
        cols = !c(peptide, aa),
        names_to = c("x", "aa_position"), names_sep = "_",
        values_to = "pep_matches",
        values_drop_na = T
        )    
      ) %>% 
  list_rbind() %>% select(!x) %>% 

# Generate rows for a each individual amino-acid at each peptide position, first by swapping rownames in column "peptide" with column names indicating peptide position,  filling missing values with "NA" ...
  pivot_wider (
    names_from = "peptide", 
    values_from = "pep_matches") %>% 
# ... then adding rows of "NA"s for the amino acids not present in the peptide ... 
  split (.$aa_position) %>% 
  map (
    function (x) 
      full_join(x, 
        Xmotifs_list %>% .[[1]] %>% 
        filter (aa_position == "p1") %>% select ("aa")
        ) %>%
    mutate(
      aa_position = na.omit (.$aa_position) %>% 
        unique ()
      ) %>% 
    arrange (aa) 
    ) %>% 
  list_rbind() %>% 
# ... and finally replacin "NA"s with 0s
  replace(is.na(.), 0)
  
# -- Optional: show tables before and after reformatting in rendered html document -- #
After <- 
  Xmotif_matches %>% 
  kable(., 200, format = "html") %>%
  kable_styling(full_width = FALSE) %>%
  scroll_box(height = "200px")

cat("###### Before \n")
cat(as.character(Before))
cat("\n\n###### After \n'")
cat(as.character(After))
cat("\n\n")
```
<br>
<!-- Close the tabset --> </div>

**_Table of the proteome search results before and after reformatting_**    
_**Before:** A total of 139 peptides were identified as potential targets of TCRs c756 and/or c796 at weakest level of response (2% cut-off, upper 95% CI limit). These included the index GLYDGMEHL with 3 matches._
_Columns named p1 - p9: amino-acid positions, pep_matches: number of human proteome matches_
_**After:** Columns named aa and aa position represent amino acids and their position, respectively. Columns labelled with peptide sequences show their number of proteome matches when a tolerated amino acid exists (aa, aa_position), otherwise the value is 0._  
<!--  --> <hr>
<br>

##### 2.5.2. Calculation of the total numbers of peptide matches at different response cut-offs

To compute the numbers of peptides tolerated by individual TCRs and at higher levels of stringency, the following chunk multiplies the binary values of Xmotif_list with the number of matches of peptides where all amino-acids are tolerated. 
<br>

```{r Chunk_8, dependson: Chunk_7}
# -- Chunk 8                                              -- #
# -- Requires object generated in chunk 2: Xmotifs_list   -- #
# -- Requires object generated in chunk 7: Xmotif_matches -- # 

## Generate a table of proteome matches for peptides potentially recognised by the two different TCRs

peptide_names <- 
  names( Xmotif_matches) %>% 
  .[!.== "aa" & !.== "aa_position"]
response_names <- 
  names( Xmotifs_list [[1]]) %>% 
  .[!.== "aa" & !.== "aa_position"] 
combinations <- 
  expand.grid( peptide = peptide_names, TCR_response = response_names)

Xmotif_matches_tbl <-  
  Xmotifs_list %>% 

# Multiply the binary values that define the X-scan motifs at different cut-offs in Xmotifs_list with numbers of proteome matches for each peptide  
  lapply(., function (x) {
    { cbind(
      select (x, c(aa, aa_position) ), 
      select (x, where (is.numeric)) %>%
        { apply(
            combinations, 1, function(row) {
              peptide <- Xmotif_matches [[row["peptide"]]]
              TCR_response <- .[[row["TCR_response"]]]
              peptide * TCR_response
              } 
            )
          } %>% 
      as_tibble() %>% 
      set_names(
        apply (
          combinations, 1, function (row) {
            paste ( row ["peptide"], row["TCR_response"], sep = "_")
            } 
          ) 
        )
      )
    } %>% 
      
# Summarise the total number of matches across all peptides
group_by( aa_position) %>% 
summarise( ., across( !c(aa), 
  function(x) sum(x))
  ) %>% 
select( !aa_position) %>% 
apply( ., 2, 
  function (x) ifelse( min(x) > 0, sum(x)/9, 0)
  ) %>% 
enframe() %>% set_names( "names", "matches") %>% 
separate( 
  names, into = c( "peptide", "TCR"), sep = "_", extra = "merge") %>% 
select( !peptide) %>% 
group_by( TCR) %>% 
summarise( 
  !!paste( names(Xmotifs_list [1]) ) := sum( matches) 
  )
} 
) %>% 
  
# For all dataframes in the list: change name of the column containing numbers of matches to names of the dataframe, join dataframes
  imap (., 
    function(df, name) {
      colnames(df)[-1] <- paste0(name)
      return(df)
    }
  ) %>% 
purrr::reduce( ., 
  function(x, y) full_join(x, y, by = "TCR")
  )

# -- Optional: show results, formatted for html display   -- #

Xmotif_matches_tbl %>% 
  kable( ., "html") %>% 
  kable_styling( 
    bootstrap_options = c( "striped", "condensed", "responsive")
    ) %>% 
  row_spec (1, background = "#dfe4f6") %>% 
  row_spec (4, background = "#f6dfdf") %>% 
  row_spec (c(2:3,5:6), background = "#fbfbfb")
```

**_Numbers of proteome matches of peptide variants potentially tolerated by TCRs c756 and c796 at response cut-offs between 2 - 40% of the response to the index peptide._**
_c756 or c796, CIhigh, CIlow: values based on the mean, upper and lower 95% CI, respectively, of the experimental data._
<!--  --> <hr>
<br>

##### 2.5.3. TCR c796 has smaller of potentially recognised peptides with matches in the human proteome suggesting higher specificity is clinically relevant

```{r Chunk_9, dependson: Chunk_8}
# -- Chunk 9                                                  -- #
# -- Requires object generated in chunk 8: Xmotif_matches_tbl -- #


# Generate log scale with unlabeled minor breaks

ymin_log10 <-  Xmotif_matches_tbl %>% select (!TCR) %>% 
  min() %>% log10() %>% as.integer() -1
ymax_log10  <- Xmotif_matches_tbl %>% select (!TCR) %>% 
  max() %>% log10() %>% as.integer() + 1

breaks <- 10^c(ymin_log10:ymax_log10)
minor_breaks <- 
  rep(1:9, ymax_log10 - ymin_log10 + 1)*
  (10^rep (ymin_log10:ymax_log10, each = 9) )

# Generate plot

Xmotif_matches_tbl %>% 

separate(TCR, into = c("TCR", "CI"), sep = "_", fill = "right") %>%
  mutate(CI = ifelse(is.na(CI), "Mean", CI)) %>% 
  pivot_longer (
    cols = -c(TCR, CI),
    names_to = "cut_off",
    values_to = "motif_size"
    ) %>% 
  pivot_wider (
    names_from = CI,
    values_from = motif_size) %>%
    
# Plot numbers of peptide matches vs. cut-off values

ggplot (aes(x = cut_off, y = Mean, group = TCR, color = TCR, fill = TCR) ) +
  geom_line() +
  geom_ribbon(aes(ymin = CIlow, ymax = CIhigh), linetype = 0, alpha = 0.3) +
  scale_colour_manual(values = c(c756 = "#435daf", c796 = "#e53935")) +
  scale_fill_manual(values = c(c756 = "#435daf", c796 = "#e53935")) +
  scale_y_log10 (breaks = breaks, minor_breaks = minor_breaks) + 
    annotation_logticks(sides = "l") +
  scale_x_discrete (breaks = seq(0, 0.4, by = 0.1), 
                    labels = seq(0, 0.4, by = 0.1)) +
  geom_vline(
    aes( xintercept = as.numeric (
      factor (0.1, levels = levels (as.factor(cut_off)))
      ),
    linetype = "Cut-off of the \ncanonical \nX-scan motif"), 
    col = "#00838f", lwd = 1.3, alpha = 0.3
    ) +
  labs(linetype = NULL) +
  xlab("Response cut-off") + 
  ylab("Number of human proteome matches") +
  theme_minimal () + 
  theme(
    axis.line = element_line(color = "darkgrey"),
    axis.ticks = element_line(color = "black"),
    axis.ticks.length = unit(0.2, "cm")
  )

```
<br>
**_Numbers of human proteome matches for peptides which are potentially recognised by the two candidate TCRs._**  
_Coloured lines represent numbers of matches for peptides comprising the X-scan motif at different cut-offs of for the T-cell response. Shaded areas indicate the 95% CIs. Blue: TCR c756, red: TCR c796. The cyan vertical line marks the cut-off used to define the canonical X-scan motifs._
<!--  --> <hr>
<br>

The plot confirms that TCR c796 had higher specificity than TCR c756 at all cut-off values. Differences in the size of the X-scan motifs became significant when amino-acid substitutions generating responses ≤ 25% of responses to the index were included. At the 10% cut-off defining the canonical X-can motif, TCR c756 was predicted to tolerate ~ 24x as many targets in the human proteome compared to TCR c796.  

These results are in qualitative agreement with the published Figure 6A. ![Figure 6A](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6343776/bin/koni-08-02-1532759-g006.jpg)
<br>
<br>
However, the present search retrieved a considerably larger number of matches. This might have been due to the use of a different human proteome database (NCBI reference vs. UniProtKB/Swiss-Prot with splice variants). Moreover, the number of known proteome sequences might have increased in the 6 years since the paper was published.
Errors in the published figure were based on the range of experimental values for each data point. By contrast, the 95% CIs are shown here which have larger margins. 
<br>
<br>

#### 2.6. Probabilities of tolerated peptides having matching sequences in the human proteome
<br>

Comparing the last figure with the corresponding plot for X-scan motif size (chunk 4) suggests that in addition to TCR c796 having a smaller repertoire of potentially recognised peptides, these also tend to have fewer matches in the human proteome. Together, this results in an even greater difference between the predicted specificities of the two TCRs.
<br>

```{r Chunk_10, dependson: Chunk_8}
# -- Chunk 10                                                  -- #
# -- Requires object generated in chunk  8: Xmotif_matches_tbl -- #
# -- Requires object generated in chunk 10: Xmotif_sizes       -- #


# Calculate proportions of X-scan motif peptides that have proteome matches

Xmotif_matches_prop <- 
  Xmotif_matches_tbl %>% 
  column_to_rownames(., "TCR")/Xmotif_sizes

# Generate log scale with unlabeled minor breaks

ymin_log10 <-  
  Xmotif_matches_prop %>% 
  min() %>% 
  log10() %>% as.integer() - 1
ymax_log10  <- 
  Xmotif_matches_prop %>% 
  max() %>% 
  log10() %>% as.integer() + 1

breaks <- 
  10^c(ymin_log10:ymax_log10)
minor_breaks <- 
  rep(1:9, ymax_log10 - ymin_log10 + 1)*
  (10^rep (ymin_log10:ymax_log10, each = 9) )

# Generate plot

Xmotif_matches_prop %>% 
  rownames_to_column ("TCR") %>% 
  separate(TCR, into = c("TCR", "CI"), 
           sep = "_", fill = "right") %>%
  mutate(CI = ifelse(is.na(CI), "Mean", CI)) %>% 
  pivot_longer (
    cols = -c(TCR, CI),
    names_to = "cut_off",
    values_to = "motif_size"
    ) %>% 
  pivot_wider (
    names_from = CI,
    values_from = motif_size) %>%
    
# Plot numbers of peptide matches vs. cut-off values

ggplot (
  aes( x = cut_off, y = Mean, group = TCR, color = TCR, fill = TCR) ) +
  geom_line() +
  geom_ribbon( 
    aes( ymin = CIlow, ymax = CIhigh), linetype = 0, alpha = 0.3) +
  scale_colour_manual(
    values = c(c756 = "#435daf", c796 = "#e53935")) +
  scale_fill_manual(
    values = c(c756 = "#435daf", c796 = "#e53935")) +
  scale_y_log10 (
    breaks = breaks, minor_breaks = minor_breaks) + 
  annotation_logticks(sides = "l") +
  scale_x_discrete (breaks = seq(0, 0.4, by = 0.1), 
                    labels = seq(0, 0.4, by = 0.1)) +
  geom_vline(
    aes( xintercept = as.numeric (
      factor (0.1, levels = levels (as.factor(cut_off)))
      ),
    linetype = "Cut-off of the \ncanonical \nX-scan motif"), 
    col = "#00838f", lwd = 1.3, alpha = 0.3
    ) +
  labs(linetype = NULL) +
  xlab("Response cut-off") + 
  ylab("Proportion of matches") +
  theme_minimal () + 
  theme(
    axis.line = element_line(color = "darkgrey"),
    axis.ticks = element_line(color = "black"),
    axis.ticks.length = unit(0.2, "cm")
  )

```
<br>

Here, I plotted the proportion of matches and its CIs against the T-cell response cut-off. It confirmed that peptide sequences derived from the X-scan motifs associated with TCR c756 were more likely to have matches in the human proteome than peptides associated with TCR c796. The difference was significant for peptides predicted to generate responses of ≤ 18% relative to the index peptide.  

Figure 6B in the published paper illustrated this point using a different metric. The naïve probability of identifying matching sequences within the proteome was defined as
$$
p(Match) = \prod_{i=1}^{n}( \frac{r_i}{20})
$$
This is equivalent to the X-scan motif size (product of all r~i~ = number of tolerated residues at position i within the sequence) of size, divided by the number of all possible variants of a peptide of the length n (20^n^).  
The results showed that with increasing probability of a match, peptide sequences derived from the X-scan motifs associated with TCR c756 were present in the human proteome more often than TCR c796-associated peptides ^2^. 
<br>
<br>

### 3. Discussion
<br>

#### 3.1. Alternatives and variants of the X-scan
<br>

The X-scan involved substitutions at all positions of the peptide. By contrast, some studies have restricted mutagenesis to amino-acids which are commonly not involved in HLA binding ("anchor residues"), under the assumption that any substitutions at these positions were likely to be deleterious ^10^. However, most TCRs appear to tolerate a limited repertoire of amino-acids, or show flexibility regarding which residues are used as anchors.

Other positional amino-acid scans have been used to study TCR specificity. In the earliest reports, substitutions were limited to alanine, or alanine and glycine. It is now widely accepted, that these were unable to assess the full range of potential TCR cross-reactvity ^2, 14^.  

Comprehensive substitution scans involving all 20 natural amino-acids can be grouped according to experimental and scoring methods.
Combinatorial peptide libraries (CPL) attempt to cover all or most of the possible amino-acid permutations by assaying library mixtures in which the peptides have a common amino-acid one position, and any of the other amino acids elsewhere ^14, 15^. Their strength compared to the X-scan is that they can detect effects arising from the interaction of multiple amino-acid substitutions in the same peptide. However, this advantage is offset by a much lower sensitivity for variants causing weak responses because of the huge number of peptides in each library mix. 

In addition to experimental differences, different scoring methods have been employed to determine whether a peptide might be tolerated. Most X-scans have regarded the response to a peptide as limited by the amino-acid substitution with the weakest response, independent of the effect(s) of any other substitution(s) that might be present. By contrast, CPL and some variants of the X-scan have assumed an additive effect when more than one amino-acid was replaced ^10, 14, 15^.

An interesting recent development are phage libraries displaying ~ 10^11 peptide variants in complex with an HLA molecule. Phage panning detected fewer tolerated variants than predicted by the X-scan, but also some that the latter had missed ^16^.

Finally, pure _in silico_ approaches have been developed for predicting cross-reactivity, based on scoring biochemical similarities between amino-acids, weighted by amino-acid position ^17, 18^.

With the above exception, few side-by-side comparisons of these methods seem to have been performed.
<br>
<br>

#### 3.2. Possible improvements of the search algorithm used in this script
<br>

An interesting alternative to Biostrings for peptide matching would have been the [AhoCorasickTrie](https://cran.r-project.org/web/packages/AhoCorasickTrie/AhoCorasickTrie.pdf) package. Its algorithm has been shown to yield much faster results when searching for exact matches. 

Time could also be saved by omitting from the proteome search any peptides containing 6-mer sequences that are known to be absent from the human transcriptome ^13^. Unfortunately, a complete list of these >56 million so-called human "null-peptides" was not easily obtainable from public sources.
<br>
<br>  

### 4. Citation
<br>
Please quote as:
Weissensteiner, Thomas.  Computing T-Cell Receptor Recognition Motifs and Their Matches in the Human Proteome. RPubs, 15 Sept. 2024. https://rpubs.com/thomas-weissensteiner/1221376.
<br>
<br>

### 5. References  
<br>

^1^ Identification of a Titin-derived HLA-A1-presented peptide as a cross-reactive target for engineered MAGE A3-directed T cells  
Cameron BJ, Gerry AB, Dukes J, Harper JV, Kannan V, Bianchi FC, Grand F, Brewer JE, Gupta M, Plesa G, Bossi G, Vuidepot A, Powlesland AS, Legg A, Adams KJ, Bennett AD, Pumphrey NJ, Williams DD, Binder-Scholl G, Kulikovskaya I, Levine BL, Riley JL, Varela-Rohena A, Stadtmauer EA, Rapoport AP, Linette GP, June CH, Hassan NJ, Kalos M, Jakobsen BK. Sci Transl Med. 2013 Aug 7;5(197):197ra103  

^2^ Affinity-enhanced T-cell receptors for adoptive T-cell therapy targeting MAGE-A10: strategy for selection of an optimal candidate  
Border EC, Sanderson JP, Weissensteiner T, Gerry AB, Pumphrey NJ. Oncoimmunology. 2018 Nov 20;8(2):e1532759  

^3^ Preclinical evaluation of an affinity-enhanced MAGE-A4-specific T-cell receptor for adoptive T-cell therapy  
Sanderson JP, Crowley DJ, Wiedermann GE, Quinn LL, Crossland KL, Tunbridge HM, Cornforth TV, Barnes CS, Ahmed T, Howe K, Saini M, Abbott RJ, Anderson VE, Tavano B, Maroto M, Gerry AB. Oncoimmunology. 2019 Nov 24;9(1):1682381

^4^ Phase 1 Clinical Trial Evaluating the Safety and Anti-Tumor Activity of ADP-A2M10 SPEAR T-Cells in Patients With MAGE-A10+ Head and Neck, Melanoma, or Urothelial Tumors  
Hong DS, Butler MO, Pachynski RK, Sullivan R, Kebriaei P, Boross-Harmer S, Ghobadi A, Frigault MJ, Dumbrava EE, Sauer A, Brophy F, Navenot JM, Fayngerts S, Wolchinsky Z, Broad R, Batrakou DG, Wang R, Solis LM, Duose DY, Sanderson JP, Gerry AB, Marks D, Bai J, Norry E, Fracasso PM. Front Oncol. 2022 Mar 18;12:818679

^5^ Phase I clinical trial evaluating the safety and efficacy of ADP-A2M10 SPEAR T cells in patients with MAGE-A10+ advanced non-small cell lung cancer  
Blumenschein GR, Devarakonda S, Johnson M, Moreno V, Gainor J, Edelman MJ, Heymach JV, Govindan R, Bachier C, Doger de Spéville B, Frigault MJ, Olszanski AJ, Lam VK, Hyland N, Navenot JM, Fayngerts S, Wolchinsky Z, Broad R, Batrakou D, Pentony MM, Sanderson JP, Gerry A, Marks D, Bai J, Holdich T, Norry E, Fracasso PM. J Immunother Cancer. 2022 Jan;10(1):e003581

^6^ Tuning T-Cell Receptor Affinity to Optimize Clinical Risk-Benefit When Targeting Alpha-Fetoprotein-Positive Liver Cancer  
Docta RY, Ferronha T, Sanderson JP, Weissensteiner T, Pope GR, Bennett AD, Pumphrey NJ, Ferjentsik Z, Quinn LL, Wiedermann GE, Anderson VE, Saini M, Maroto M, Norry E, Gerry AB.
Hepatology. 2019 May;69(5):2061-2075

^7^ Preclinical Studies of the Off-Target Reactivity of AFP(158)-Specific TCR Engineered T Cells  
Cai L, Caraballo Galva LD, Peng Y, Luo X, Zhu W, Yao Y, Ji Y, He Y.Front Immunol. 2020 Apr 27;11:607 

^8^ T cells targeted to TdT kill leukemic lymphoblasts while sparing normal lymphocytes  
Ali M, Giannakopoulou E, Li Y, Lehander M, Virding Culleton S, Yang W, Knetter C, Odabasi MC, Bollineni RC, Yang X, Foldvari Z, Böschen ML, Taraldsrud E, Strønen E, Toebes M, Hillen A, Mazzi S, de Ru AH, Janssen GMC, Kolstad A, Tjønnfjord GE, Lie BA, Griffioen M, Lehmann S, Osnes LT, Buechner J, Garcia KC, Schumacher TN, van Veelen PA, Leisegang M, Jacobsen SEW, Woll P, Olweus J. Nat Biotechnol. 2022 Apr;40(4):488-498

^9^ A systematic safety pipeline for selection of T-cell receptors to enter clinical use  
Foldvari Z, Knetter C, Yang W, Gjerdingen TJ, Bollineni RC, Tran TT, Lund-Johansen F, Kolstad A, Drousch K, Klopfleisch R, Leisegang M, Olweus J. NPJ Vaccines. 2023 Aug 22;8(1):126

^10^ Enhanced T cell receptor specificity through framework engineering  
Rosenberg AM, Ayres CM, Medina-Cucurella AV, Whitehead TA, Baker BM. Front Immunol. 2024 Mar 12;15:1345368  

^11^ PlotDigitizer, 3.1.5, 2024, plotdigitizer.com

^12^ Introduction to Bioinformatics  
Lesk A. Oxford University Press. 4th ed. 2014. ISBN-13 978-0199651566  

^13^ kmerDB: A database encompassing the set of genomic and proteomic sequence information for each species  
Mouratidis I, Baltoumas FA, Chantzi N, Patsakis M, Chan CSY, Montgomery A, Konnaris MA, Aplakidou E, Georgakopoulos GC, Das A, Chartoumpekis DV, Kovac J, Pavlopoulos GA, Georgakopoulos-Soares I. Comput Struct Biotechnol J. 2024 Apr 21;23:1919-1928. 

^14^ TCR Fingerprinting and Off-Target Peptide Identification  
Karapetyan AR, Chaipan C, Winkelbach K, Wimberger S, Jeong JS, Joshi B, Stein RB, Underwood D, Castle JC, van Dijk M, Seibert V. Front Immunol. 2019 Oct 22;10:2501. doi: 10.3389/fimmu.2019.02501

^15^ Preclinical Strategies to Identify Off-Target Toxicity of High-Affinity TCRs  
Bijen HM, van der Steen DM, Hagedoorn RS, Wouters AK, Wooldridge L, Falkenburg JHF, Heemskerk MHM. Mol Ther. 2018 May 2;26(5):1206-1214

^16^ TCRs with Distinct Specificity Profiles Use Different Binding Modes to Engage an Identical Peptide-HLA Complex  
Coles CH, Mulvaney RM, Malla S, Walker A, Smith KJ, Lloyd A, Lowe KL, McCully ML, Martinez Hague R, Aleksic M, Harper J, Paston SJ, Donnellan Z, Chester F, Wiederhold K, Robinson RA, Knox A, Stacey AR, Dukes J, Baston E, Griffin S, Jakobsen BK, Vuidepot A, Harper S. J Immunol. 2020 Apr 1;204(7):1943-1953

^17^ PepSim: T-cell cross-reactivity prediction via comparison of peptide sequence and peptide-HLA structure  
Hall-Swan S, Slone J, Rigo MM, Antunes DA, Lizée G, Kavraki LE. Front Immunol. 2023 Apr 28;14:1108303

^18^ CrossDome: an interactive R package to predict cross-reactivity risk using immunopeptidomics databases  
Fonseca AF, Antunes DA. Front Immunol. 2023 Jun 12;14:1142573
<br>
<br>

### 6. Appendix: Optimizing the number of cores for parallel computing
<br>


```{r, Test, eval = FALSE}
## This script can be run to determine the optimal number of cores for parallel processing in chunk 6

# The test file is a dataframe where each row represents a peptide, columns amino-acid positions, and values amino-acid names in single letter code (here: 500 peptides from Xmotif_max)
Xmotif_test <- Xmotif_max[3648201: 3648700, ]

cores = c(1: detectCores())

t_sys <- list()

for (j in cores) {

  cl <- makeCluster(j)

  clusterExport(cl, c("human_proteome", "Xmotif_max", "findMatches"))

  clusterEvalQ( cl,
    { library(dplyr)
      library(purrr)
      library(Biostrings)
    } )

  n = 1
  Xmotif_matches <- list()

  t_sys[[j]] <- 
  system.time(
    for (i in 1:n) {
      Xmotif_matches[[i]] <- 
        Xmotif_test %>%  
        .[( (i-1)*nrow(.)/n + 1 ) : (i*nrow(.)/n), ] %>% 
        parApply(cl, ., 1, findMatches) %>% unlist 
    }
  ) %>% 
  unlist %>% t %>% as.data.frame.array

stopCluster(cl)
}

t_sys %>% 
  list_rbind() %>% 
  select(., "Time[s]" = elapsed) %>%  cbind ("Cores" = cores, .)

```
<br>
```{r table, echo = FALSE}
kable(cores_time <- read.delim ( "cores_time.csv")%>% set_names(c("Cores", "Time[sec]")) )
```
<br>

Trade-off between CPU and memory usage means that the relationship between the number of cores and elapsed time can be complex. With the PC and test file used here, the elapsed time running the test with maximum number of 16 cores was 31.6 s. However, the two settings with the fastest performance were 10 cores (21.3 s) and 12 cores (19.9 s).  

PC used in this work: Intel(R) Core(TM) i7-10700T CPU @ 2.00GHz, 16GB RAM
OS: Windows 11 Pro

