---
title: "Computing T-cell receptor recognition motifs and their matches in the human proteome"
author: "Thomas Weissensteiner"
date: "2024-08-02"
output:
  html_document:
    code_folding: show
    toc: true
    toc_float: true
    toc_depth: 4
---
**My scripts:**  

* rendered html versions: [Rpubs/thomas-weissensteiner](https://rpubs.com/thomas-weissensteiner)  
* .rmd files with executable code chunks: www.github.com/thomas-weissensteiner/portfolio/tree/main/  

**About myself:** www.linkedin.com/in/ThomasWs-Mopfair

<br> 
```{r Options, include = FALSE}
## Global directory and output options 

# The working directory in "Global directory and output options" needs to be customised, and should include the following additional files:
# "                                         .csv", the example data file

# "Summarizing_Human_Phenotype_Ontology_Terms_figs", a folder containing additional figures not generated by the code chunks  

knitr::opts_knit$set(root.dir = "C:/Users/ThomasWeissensteiner/OneDrive/Documents/portfolio/MAGEA10_paper")
knitr::opts_chunk$set (warning = FALSE)
knitr::opts_chunk$set (tidy = FALSE)
knitr::opts_chunk$set (attr.output='style="max-height: 100px;"')

# R package for rendering tables in HTML format (kableExtra rather than kable is required for R 4.3.0)

library(kableExtra)
```
<br>
<br>  

### 1. Background and motivation 
<br>
<br>  
The adoptive transfer of T-cells which recognise and kill transformed cells have shown promise as an emerging anti-cancer therapy. The cancer-killing potency of T-cells can be enhanced by genetic engineering of the T-cell receptor (TCR) to increase its affinity for cancer-expressed antigens.  

However, this manipulation also risks generating cross-reactivity to antigens expressed by normal tissue, as shown in some high-profile cases with serious consequences. _In vitro_ testing and testing in animal models might not detect such cross-reactivity due to cell culture and species-specific differences in the antigenic repertoire ^1^. 
To mitigate the risk of off-target toxicities in future clinical trials, Adaptimmune developed an extensive in-vitro testing pipeline. A pivotal element was predicting the repertoire of peptides in the human proteome that a given TCR might recognize ^2^. Experimental testing of all possible combinations of 20 amino-acids at 9 peptide positions would have been prohibitive (n = 9^20 variants). 
Therefore, the repertoire of potentially recognised peptides was inferred by a combined _in vitro_ / in silico approach:  
1. _In vitro_ assays were performed with peptides carrying sequential substitutions at a single position (n = 9 x 20)
2. Single amino-acid substitutions for which T-cell responses exceeded a certain threshold (percentage of response to the target of index peptide) were defined as "tolerated"
3. A combinatorial motif was constructed of all tolerated amino-acid substitutions, and the human proteome search for matches with this motif
This strategy was implemented for prioritizing a candidate TCR for further extensive pre-clinical and clinical testing. Notably, the X-scan method allowed to discriminate between two TCRs which appeared to be equally optimal in conventional biochemical and cellular assays.  

Subsequently, several reports have used the same method but no code was made available ^2-4^. I set myself a challenge to reproduce the X-scan results in [Figures 5](https://www.tandfonline.com/cms/asset/2ec10c4e-15c9-43de-b438-a0c656b688ce/koni_a_1532759_f0005_oc.jpg) and [Figure 6](https://www.tandfonline.com/cms/asset/340f8f57-28fc-4022-8639-17b0c599c591/koni_a_1532759_f0006_oc.jpg) of our paper by writing an R script that handles millions of string searches efficiently.  
I also added some further analyses of the published data.
<br>
<br>  


### 2. Code and figures
<br>
<br>
#### ---- WIP: Flowchart of the X-scan method

1. _In vitro_ T-cell responses to the index peptide and its amino-acid substitution variants
[thumbnail of barchart]
180 peptides (9 amino-acid positions * 20 natural amino-acids)
2. Calculate ratios of variants/ index peptide
3. Define threshold variant / index ratio that defines a "tolerated" amino-acid substitution


4. Generate a list of all potentially tolerated peptides represented by all  permutations of amino-acids tolerated by a TCR (> 3.000.000 at the lowest threshold)

5. Search peptide matches in human proteins - these represent potential targets for   T-cell reactivity against normal tissue, requiring further investigation
5. Repeat 2.-4. for different threshold levels and their experimental error ranges
6. Repeat 1.-5. for the second candidate TCR, plot the results and compare specificity

<br>  

#### 2.1. Required R packages and data file
<br>

```{r Chunk_1, message = FALSE}

## Load required R libraries and datasets

# library(tidyverse)
library(dplyr)
library(purrr)        # purr::set_names
library(tidyr)        # tidyr::pivot_longer, tidyr::pivot_wider
library(tibble)       # tibble::tibble, tibble::as_tibble, tibble::column_to_rownames
library(biomartr)     # biomartr::getProteome, biomartr::read_proteome
library(Biostrings)   # for searching the proteome
library(parallel)     # for parallel processing of search tasks
library (ggplot2)     #
library(progress)     # for monitoring progress in the execution of proteome searches
# library(scales)       # for log scales with minor line breaks in ggplot
# library(kmers)
# library(ggpubr)


# Human proteome data

HS.proteome.refseq <- 
  getProteome( db = "refseq", organism = "Homo sapiens",
               gunzip = FALSE,
               path = file.path("_ncbi_downloads","proteomes"))

human_proteome <- read_proteome(file = HS.proteome.refseq)


# T-cell response data (tab-delimited .csv document)

Xscan <- read.delim ("C:/Users/ThomasWeissensteiner/OneDrive/Documents/portfolio/MAGEA10_paper/Xscan_c796c756.csv")

# ----- WIP  "https://raw.githubusercontent.com/thomas-weissensteiner/portfolio/main/Summarizing_Human_Phenotype_Ontology_Terms/variants_simulated.csv", 

Xscan
```
_*T-cell response experimental data.* The T-cell response data in this file were obtained from figure S2 ^2^ using PlotDigitizer ^5^. In the column names, "position" means amino-acid position in the 9mer peptide, "aa": amino-acid (one letter code), "count": interferon gamma spot count (number of responding T-cells), "SE": standard error of the mean, "index": an amino-acid of the index peptide if the value is "1"._
<br>
<br>

##### 2.2. Generate lists of potentially recognised peptides for a range of T-cell response thresholds
<br>
```{r Chunk_2, dependson: Chunk_1}
# -- Requires object Xscan generated by chunk 1 -- #

### Data cleaning and transformation

# Replace all NAs with 0s

Xscan <- Xscan %>% replace(is.na(.), 0)


# Convert T-cell response counts + SE to counts +/- 95% CI

Xscan <- Xscan %>%
  mutate (c796count_CI = (c796count_SE - c796count) * 1.96, 
          c756count_CI = (c756count_SE - c756count) * 1.96) %>% 
  mutate (c796count_CIlow = c796count - c796count_CI, 
          c796count_CIhigh = c796count + c796count_CI,
          c756count_CIlow = c756count - c756count_CI, 
          c756count_CIhigh = c756count + c756count_CI) %>% 
  select (aa_position, aa, 
          c796count, c796count_CIlow, c796count_CIhigh,
          c756count, c756count_CIlow, c756count_CIhigh,
          Index)


# Filter counts for responses to the index peptide

indexCounts <- Xscan %>% 
  filter (., Index == 1) %>% .[1, 
    c("c796count", "c796count_CIlow", "c796count_CIhigh", 
      "c756count", "c756count_CIlow", "c756count_CIhigh") ] 


# Generate a dataframe of T-cell response values divided by the response to the index peptide

Xscan_norm <- Xscan %>% 
  mutate (c796        = c796count/indexCounts$c796count,
          c796_CIlow  =  c796count_CIlow/ indexCounts$c796count_CIhigh,
          c796_CIhigh =  c796count_CIhigh/ indexCounts$c796count_CIlow,  
          c756        = c756count/indexCounts$c796count,
          c756_CIlow  =  c756count_CIlow/ indexCounts$c796count_CIhigh,
          c756_CIhigh =  c756count_CIhigh/ indexCounts$c796count_CIlow ) %>% 
  select (aa_position, aa ,
          c796, c796_CIlow, c796_CIhigh,  
          c756, c756_CIlow, c756_CIhigh ) 


## Generate logical tables of amino-acid substitutions that are tolerated at various fractions of the response to the index peptide

cut_off <- seq(0.02, 0.4, 0.02) 

Xmotifs_list <- lapply (cut_off, 
  function (x) {
    # categorise response ratios according to being equal or greater than a cut_off value 
    Xscan_norm %>% mutate(across (!c(aa, aa_position), ~. >= x )) %>%
    # convert logical values to binary numbers:
                   mutate(across (!c(aa, aa_position), ~+.))         
    } ) %>% 
  set_names (., cut_off)

```
Note: The original paper uses the ranges of count ratios obtained from of triplicate experiments for computing the X-scan motifs. However, only the means and their standard errors (SE) were reported. When trying to replicate the figures with the published data, I therefore decided to use 95% confidence intervals (CI) instead.  
CIs are wider than SEs but might be more appropriate for two reasons: firstly, we should be concerned here about the ranges of response rather than the precision of their means; secondly, CIs allow proper error propagation when transforming counts to count ratios.
<br>
<br>

#### 2.2. Generating the canonical X-scan motifs of TCRs c796 and c756
<br>
The canonical X-scan motif comprises all permutations of single amino-acid substitutions that are tolerated at a 10% response compared to the index peptide. The product of the numbers of recognized residues at each position is the motif size, or number of peptide sequences that are potentially by a TCR. The method does not account for compensatory, or additive or synergistic inhibitory effects that might arise from interactions of the amino acid substitutions.

```{r Chunk_3, dependson: Chunk_2, results= 'hold'}
# -- Requires Xmotifs_list generated by chunk 2 -- #

## Plot details for amino-acids tolerated at 10% of more (X-scan motif: see Fig. 5C in ref. 1 for for comparison)

Fig5_aas <-  
  Xmotifs_list$"0.1" %>% 
    select (aa_position, aa, c796, c756) %>% 
      pivot_longer (cols = c(c796, c756), names_to = "TCR") %>%
      pivot_wider(names_from = c(aa_position), values_from = value) %>% 
    mutate (across (c(p1, p2, p3, p4, p5, p6, p7, p8, p9), 
      ~ ifelse( . == 1, aa, "") ) 
      ) 
       
# Add a columns with amino-acid properties 

Fig5_aas <- Fig5_aas  %>% mutate (aa_property = aa, .before = aa) %>% 
  mutate (aa_property = case_when (
      aa_property %in% c("D", "E")                ~ "Negative charge",
      aa_property %in% c("H", "K", "R")           ~ "Positive charge",
      aa_property %in% c("N", "Q", "S", "T", "C") ~ "Polar",
      aa_property %in% c("A", "G", "P")           ~ "Small, non-polar",
      aa_property %in% c("Y", "W", "F")           ~ "Aromatic, uncharged",
      aa_property %in% c("M", "L", "V", "I")      ~ "Alipathic"
      ) %>% 
      factor(levels = c("Negative charge", "Positive charge", "Polar", 
                        "Small, non-polar", "Aromatic, uncharged", "Alipathic") )
      ) %>% 
  select (!aa) %>% 
  group_by(aa_property, TCR) %>%
    summarise(across(c(p1, p2, p3, p4, p5, p6, p7, p8, p9), 
      function (x) paste(unique(x[x != ""]), collapse = ", ")), 
      .groups = 'drop')

Fig5_sums <- Xmotifs_list$"0.1" %>%         
  select (c(aa_position, aa, c756, c796)) %>% 
  group_by(aa_position) %>% 
  summarise(c756 = sum(c756),
            c796 = sum(c796) ) %>% 
  pivot_longer(cols = c(c756, c796), names_to = "TCR") %>% arrange("TCR") %>% 
  pivot_wider(names_from = c(aa_position), values_from = value) %>% 
  {cbind (aa_property = c("Total", "Total"), .)}


rbind (Fig5_aas, Fig5_sums) %>% data.frame() %>% 

# Add formatting for pretty display in an html page
  
  kable(., "html") %>% kable_styling(bootstrap_options = c("striped", "condensed", "responsive")) %>% row_spec(c(13,14), bold = T)
```
<br>
_*Amino acid substitutions tolerated by TCRs c756 and c796 (cannonical X-scan motif).*
_aa_property: amino-acid property; TCR: T-cell receptor; p1-9: amino-acid positions in the 9-mer peptide._  

_\(A) Pie areas are proportional to the number of tolerated amino-acids, including the index. Pie segments represent a breakdown of tolerated amino-acids into groups with similar physico-chemical properties ^6^. The area within the outer circle corresponds to all 20 amino-acids being tolerated at a 10% threshold; the circle color indicates the property of the index peptide. \(B) Comparison of the X-scan search motifs for c756 and c796 at a response threshold of 10%. \(C) Total number of tolerated residues at each peptide position, including the index. The number of residues that would be identified as potentially tolerated by an alanine scan is shown for comparison._
<br>

For comparison, this is [Figures 5](https://www.tandfonline.com/cms/asset/2ec10c4e-15c9-43de-b438-a0c656b688ce/koni_a_1532759_f0005_oc.jpg) of the paper ^2^ which I generated manually in Excel:  [![](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6343776/bin/koni-08-02-1532759-g005.jpg)]
<br>
<br>

#### 2.3. Comparing specificity of TCRs c756 and c796, according to the number of potentially recognized peptides indicated by the size of their X-scan motifs
<br>

```{r Chunk_4, dependson: Chunk_2, message = FALSE}
# Requires objects generated in chunk 2: cut_off, Xmotifs_list  

## Plot dependence of X-scan motif size on response cut-off

# Generate a dataframe of X-scan motif sizes for each TCR (column) and cut-off value (row)

Xmotif_sizes <- Xmotifs_list %>% 
  lapply(., function(x) {
    x %>% group_by(aa_position) %>% 
      summarise(across(where(is.numeric), ~ sum(.))) %>% 
      select (!aa_position)
    }
  )

Xmotif_sizes <- Xmotif_sizes %>% 
  lapply (., function (x) apply (x, 2, prod)) %>% 
  cbind.data.frame()


# Generate log scale with unlabeled minor breaks

ymin_log10 <-  min(Xmotif_sizes) %>% log10() %>% as.integer()
ymax_log10  <- max(Xmotif_sizes) %>% log10() %>% as.integer() +1

breaks <- 10^c(ymin_log10:ymax_log10)
minor_breaks <- 
  rep(1:9, ymax_log10 - ymin_log10 + 1)*
  (10^rep (ymin_log10:ymax_log10, each = 9) )

# Generate plot

Xmotif_sizes %>% 
  rownames_to_column ("TCR") %>% 
  separate(TCR, into = c("TCR", "CI"), sep = "_", fill = "right") %>%
  mutate(CI = ifelse(is.na(CI), "Mean", CI)) %>% 
  pivot_longer (
    cols = -c(TCR, CI),
    names_to = "cutoff",
    values_to = "motif_size"
    ) %>% 
  pivot_wider (
    names_from = CI,
    values_from = motif_size) %>%
    
ggplot (aes(x = cutoff, y = Mean, group = TCR, colour = TCR) ) + 
  geom_line() +
  geom_ribbon(aes(ymin = CIlow, ymax = CIhigh, fill= TCR), alpha = 0.3) +
  scale_colour_manual(values = c(c756 = "blue", c796 = "red")) +
  scale_fill_manual(values = c(c756 = "blue", c796 = "red")) +
  scale_y_log10 (breaks = breaks, minor_breaks = minor_breaks) + 
    annotation_logticks(sides = "l") +
  scale_x_discrete (breaks = seq(0, 0.4, by = 0.1), 
                    labels = seq(0, 0.4, by = 0.1)) +

  geom_vline(
    aes(xintercept = 
          as.numeric (factor (0.1, levels = levels (as.factor(cutoff)))),
    linetype = "Cut-off of the \ncanonical \nX-scan motif"), 
      col = "cyan", lwd = 1.3) +
      labs(linetype = NULL) +
    
  xlab("Response cut-off") + 
  ylab("X-scan motif size (number of peptides) ") +
  theme_minimal()

```
<br>
_*Numbers of peptides which are potentially recognised by each TCR and their 95% CIs.* Coloured lines represent the X-scan motif sizes base on the mean response to peptides with single amino acid substitutions. Shaded areas indicate 95% CIs. Blue: TCR c756, red: TCR c796. The vertical line marks the cut-off used to define the cannonical X-scan motifs, based on peptides generating at least 10% of the response generated by the index peptide (^2-4^)._  

It is evident that at the  the two TCRs have significantly different specificity when amino acid substitutions generating such weak responses are included: The number of peptides that are potentially recognised is ~ 10x greater for c756 compared to c796.  
<br>
<br>

#### 2.4. Searching for peptides in the human genome that match the X-scan motif and are potential causes for T-cell responses against healthy tissue  
<br>
A vast majority of the peptides comprising the X-scan motif are not expressed by human tissues. Therefore, we performed a search of the human proteome with the X-scan motifs of the two TCRs for a clinically more relevant comparison of their specificity.  
In addition, the reactivity of T-cells against tissues _in vivo_ might differ from their _in vitro_ response, such as the IFN-gamma spot count. The 10% cut-off used to define the cannonical X-scan motif was a conservative choice. Therefore, I suggested to compare the specificity of the two TCRs candidates also over a range of other cut-off values, as shown in the following paragraphs.
<br>
```{r Chunk_5, dependson: Chunk_2, message = FALSE}
# Requires objects generated in chunk 2: cut_off, Xmotifs_list 

# ------- WIP

TCR_list <- list ("c756", "c796")

# for (i in seq_along(TCR_list) ) {

# -------
i = 2

  TCR <- paste0(TCR_list[i], "_CIhigh")
  
# Generate amino acid combinations for largest X-scan motif (lowest T-cell response threshold)
  
  Xmotif_max <- Xmotifs_list[[paste(min(cut_off))]] %>% 
    select (aa_position, aa, all_of(TCR)) %>% 
    pivot_wider(., names_from = "aa_position", values_from = paste(TCR)) %>% 
    apply(., 2, function(x) .$aa[x>0]) %>% .[setdiff(names(.), "aa")] %>% 
    expand.grid(stringsAsFactors = F)


## Perform search in n chunks and backup intermediate results (search may take several days on a PC, even with parallel processing) 


# Function for performing (human) proteome searches with X-scan motifs
# Input: dataframe of amino-acids in the different positions (columns) of each peptide (rows)
# Output: list of the number of matches (value) for each peptide found in the proteome, shown by its row index in the input file (name)
  
findMatches <- function (Xmotif, ome = human_proteome) {
  pep <- paste(Xmotif, collapse = "")
  pepMatch <- vmatchPattern (pep, ome) %>% elementNROWS() %>% sum
    if (pepMatch > 0) { 
        return(c (pepMatch, rownames(Xmotif)) )
    } 
}


# Set up PC (Windows OS) for parallel processing of peptide searches in the human proteome
# Make sure to turn off automatic "sleep" in your PC's settings

cl <- makeCluster(10)
# detectCores(): socket cluster with 16 nodes on host ‘localhost’, but 10 cores provide optimal speed

clusterExport(cl, c("human_proteome", "Xmotif_max", "findMatches"))

clusterEvalQ(cl,
  { library(dplyr)
    library(purrr)
    library(Biostrings)
  })


# Set up a sub-directory for backing up partial search results

dir.create(file.path(paste(getwd()), paste0("Xmotif_matches_", TCR)))
setwd(file.path(paste(getwd()), paste0("Xmotif_matches_", TCR)))


# Determine number of times partial search results will be saved (nrow(Xmotif_max)/n must be an integer!)

n <- 20


# Initialise progress bar and list of search results

pb <- progress_bar$new (format = "(paste(TCR), :percent [Estimated time: elapsed > :elapsedfull , remaining < :eta]",
  total = n,
  clear = F,        # don't clear bar when finished
  )

Xmotif_matches <- list()


# Loop through proteome searches with sequential subsets of the maximum size X-scan motif

for (i in 1:n) {
  Xmotif_matches [[i]] <-
    Xmotif_max  %>% 
      .[( (i-1)*nrow(.)/n + 1 ) : (i*nrow(.)/n), ] %>% 
      parApply(cl, ., 1, function (x) findMatches (x)) %>% unlist 
    write.csv(Xmotif_matches[i] %>% as.data.frame %>% set_names("matches"), 
      paste0("Xmotif_matches_", i, ".csv") )
    pb$tick()
}


# Reset to serial processing and original working directory

stopCluster(cl)
setwd("..")


Xmotif_matches <- Xmotif_matches %>% unlist
```
Numbers of peptides tolerated at different response thresholds (TCR c976)
<br>
<br>

### 2.4. Computing peptide matches
<br>

#### 2.4.1. Some wrangling acrobatics

```{r Chunk_6, dependson: Chunk_5, message = FALSE}
# Requires objects generated in chunk 2: Xmotifs_list 
# Requires objects generated in chunk 5: Xmotif_max, Xmotifs_matches

## Extract table of amino acids from Xmotif_max for peptides with human proteome matches, and join it with Xmotif_matches

matches_index <- Xmotif_matches %>% names %>% as.numeric()

test <- full_join (
    
    Xmotif_max[matches_index, ] %>% cbind (matches_index = rownames(.),. ),
    
    
    Xmotif_matches %>% cbind.data.frame() %>% cbind (matches_index = rownames(.),. ) %>% set_names(c("matches_index", "pep_matches"))
    
)

## Show peptides and numbers of proteome matches

test %>% select(., !matches_index) %>% rowwise() %>% mutate (., peptide = paste( c_across(!pep_matches), collapse = "")) %>% select (., c(peptide, pep_matches)) %>% arrange(desc(pep_matches))

##  Wrangle Xmotif_matches into a dataframe of  the same format as the dataframes in Xmotifs_list

test <- test %>% select(., !matches_index) %>%     

# Collapse tolerated amino acids to generate peptide names
  rowwise() %>% mutate (., 
    peptide = paste( c_across(!pep_matches), collapse = "")) %>% 

# Pivot amino-acid positions to column "aa_position" and their values into a new column "aa" for amino-acids
  pivot_longer (
    cols = !c(peptide, pep_matches), 
    names_to = "aa_position", 
    values_to = "aa") %>%
  pivot_wider (
    names_from = !c(peptide, aa), 
    values_from = pep_matches) %>% 
  split(., .$peptide) %>% 
    map (., function (x) 
      pivot_longer(x, 
        cols = !c(peptide, aa),
        names_to = c("x", "aa_position"), names_sep = "_",
        values_to = "pep_matches",
        values_drop_na = T
        )    
    ) %>% 
  list_rbind() %>% select(!x) %>% 

# Generate rows for a each individual amino-acid at each peptide position,
# by swapping rownames in column "peptide" with column names indicating peptide position, and filling missing values with "NA" 
  pivot_wider (
    names_from = "peptide", 
    values_from = "pep_matches") %>% 

  split (., .$aa_position) %>% 
  map (., function (x) 
    full_join(x, 
      Xmotifs_list %>% .[[1]] %>% 
      filter (aa_position == "p1") %>% select ("aa")) %>%
    mutate (aa_position = na.omit (.$aa_position) %>% unique ()) %>% 
    arrange (aa) 
    ) %>% 
list_rbind() 

# Xmotif_matches in new format  
test

# Show for comparison 
Xmotifs_list$"0.4"
```
The first of the above tables shows the results of the proteome search.
A total of 48 peptides with 307 matches were identified as potential targets of TCR c796 when including the weakest level of response (2% cut-off, upper 95% CI limit). These included 3 matches for the index peptide, GLYDGMEHL.  

An efficient way to compute the numbers of peptides tolerated at higher levels of stringency is to multiply the binary values of Xmotif_list with the number of matches of peptides where all amino acids are tolerated. For this, Xmotif_matches needs to converted to a format where 
- rows represent all  combinations of amino-acid position and amino acids,
- column names of potentially tolerated peptides found in the human proteome
- values the number of proteome matches  

The second of the above tables shows the proteome search results in this new format.

```{r Chunk_7, dependson: Chunk_6}
# Requires objects generated in chunk 2: Xmotifs_list 
# Requires objects generated in chunk 6: test 

# WORKS!
test %>% 
  group_by (aa_position) %>% 
  summarise(., across(!c(aa), function(x) sum(!is.na(x)))) %>% 
  select (!aa_position) %>% 
  colMeans()

# INTERESTING

test <- test %>% replace(is.na(.), 0)
  
test %>% 
  mutate (., across (!c(aa, aa_position), 
    function (x) x*Xmotifs_list [[1]] %>% pull(c796))) %>%   
  group_by (aa_position) %>% 
    summarise(., across(!c(aa), function(x) sum(x))) %>% 
    select (!aa_position) %>% 
    apply (., 2, function (x) ifelse (min(x) > 0, sum(x)/9, 0)) %>% 
    sum()

# Generate the products of between matches of each peptide and X-scan motifs for the mean, lower and upper CI of the responses
peptide_names <- names(test) %>% .[!.== "aa" & !.== "aa_position"]
response_names <- names (Xmotifs_list [[1]]) %>% .[!.== "aa" & !.== "aa_position"] 
combinations <- expand.grid(peptide = peptide_names, TCR_response = response_names)

Xmotifs_list [[1]] %>%
  { cbind (
    select (., c(aa, aa_position) ), 
    select (., where(is.numeric)) %>%
      {apply(combinations, 1, function(row) {
        peptide <- test [[row["peptide"]]]
        TCR_response <- .[[row["TCR_response"]]]
        peptide * TCR_response
        } )
      } %>% 
      as_tibble() %>% set_names(
        apply (combinations, 1, function (row) {
          paste ( row ["peptide"], row["TCR_response"], sep = "_")
        } 
      ) 
    )
  )} %>% 
  
group_by (aa_position) %>% 
    summarise(., across(!c(aa), function(x) sum(x))) %>% 
    select (!aa_position) %>% 
    apply (., 2, function (x) ifelse (min(x) > 0, sum(x)/9, 0)) %>% 

pivot_longer(
      cols = !c("aa", "aa_position"),
      names_to = c("peptide", "TCR_response"),
      names_pattern = "(.+)_(.+)",
      values_to = "peptide_matches" )
# should be this format:
aa  aa_position AAYMAPERI AAYMAPEVI 
    <chr>       <chr>      <int>        
A     p1         4         5        

%>% 
    group_by (aa_position) %>% 
    summarise(., across(!c(aa), function(x) sum(x))) %>% 
    select (!aa_position) %>% 
    apply (., 2, function (x) ifelse (min(x) > 0, sum(x)/9, 0)) %>% 
    sum()


```








# set up for parallel processing (Windows OS)
# Thanks to for Josh Errickson: https://dept.stat.lsa.umich.edu/~jerrick/courses/stat506_f23/17-parallel-processing.html#using-sockets-with-parlapply
cl <- makeCluster(10)
# detectCores(): socket cluster with 16 nodes on host ‘localhost’, but 10 cores provide optimal speed
clusterExport(cl, c("human_proteome", "Xmotifs_table", "findMatches"))
clusterEvalQ(cl,
  { library(dplyr)
    library(purrr)
    library(Biostrings)
  })

 system.time( 
  Xmotif_matches <-
    # Xmotifs_table %>% .[1:100, ] %>% 
    # pull(min(cut_off) %>% as.character()) %>% 
    c("AIFDSMQMA", "PAYDSPEVF", "HIFCAMEQI", "AIYDTMQYI", "GLYDGMEHL", "PCFCSPQRL", "VNYDAPQYL", "TTYCSPEYT") %>% 
     parLapply (cl, ., function (x) findMatches (x)) %>% 
    unlist
   )

stopCluster(cl)

Xmotif_matches
```

-------------
# Co-pilot

find_matching_proteins <- function(peptide, proteome) {
    matches <- vmatchPattern(peptide, proteome)
    matching_proteins <- names(proteome)[sapply(matches, length) > 0]
    return(matching_proteins)
}


### Comparision with standard serial processing

```
{r Chunk_4, dependson: Chunk_2}
## Run Chunk 2 first each time before running Chunk 4 to reset Xscan_norm ##

# Range of T-cell response thresholds defining "tolerated" amino-acids
# Residues tolerated at 10% of the index response (cut_off = 0.1) shown by running chunk 3

cut_off <- seq(0.1, 0.4, 0.02) 


# Choose TCR to be evaluated

TCR <- "c796"
      # "c756"


# Generate a list of strings representing all possible combinations of amino-acids at each position, using amino-acids tolerated at the lowest response cut_off and responses plus their SE

TCR <- paste0 (TCR, ".+SE")



Xscan_norm <- Xscan_norm %>% select (position,  aa, all_of(TCR) ) %>% 
  pivot_wider(names_from = position, values_from = TCR) %>% 
  column_to_rownames("aa")

generate_Xmotif <- function (cut_off, Xscan_norm) {
  Xmotif <- Xscan_norm
  Xmotif [Xmotif < cut_off] <- NA

  Xmotif <- Xmotif %>% {.>0} %>% apply(., 2, function(x) rownames(.)[x>0])

Xmotif <- Xmotif %>% 
  apply(., 2, function(x) x[!is.na(x)] ) %>% {expand.grid(.)} %>% 
  apply (., 1, function (x) paste(x, collapse = ""))
}


Xmotifs_table <- tibble(generate_Xmotif (min (cut_off), Xscan_norm)) %>% set_names(min (cut_off))



Xmotifs_table %>% pull(min(cut_off) %>% as.character())
```

## {-}



```{r Chunk_x, dependson: Chunk_y}




```



<br>
<br>

 
https://dept.stat.lsa.umich.edu/~jerrick/courses/stat506_f23/17-parallel-processing.html#using-sockets-with-parlapply
cl <- makeCluster(10)
# detectCores(): socket cluster with 16 nodes on host ‘localhost’, but 10 cores provide optimal speed
clusterExport(cl, c("human_proteome", "Xmotifs_table", "findMatches"))
clusterEvalQ(cl,
  { library(tidyverse)
  library(Biostrings)
  })

# system.time( 
  Xmotif_matches <-Xmotifs_table %>% 
     pull(min(cut_off) %>% as.character()) %>% 
     parLapply (cl, ., findMatches
     ) %>% unlist
  # )

stopCluster(cl)

# 
# ```

#### 2.3. Otimizing the number of cores for parallel computing

![Scaling of system time with nunber of cores]("C:/Users/ThomasWeissensteiner/OneDrive/Documents/portfolio/MAGEA10_paper/coreNumber_optimization_parallelComputing")



The ranges of tolerated peptide numbers resulting from considering the standard error of three T-cell response measurements are shown in as light red or light blue shade. In the published figure, these ranges were based on the maximum and minimum of each triplicate measurement.

<br> 

<br>
<br>  

### 5. Possible improvements

An interesting alternative to Biostrings for peptide matching would have been the [AhoCorasickTrie](https://cran.r-project.org/web/packages/AhoCorasickTrie/AhoCorasickTrie.pdf) package. Its algorithm has been shown to yield much faster results when searching for exact matches. However, newer versions of R are currently not supported.





### 3. References  

?) CPL scan

^1^ [Identification of a Titin-derived HLA-A1-presented peptide as a cross-reactive target for engineered MAGE A3-directed T cells](https://doi.org/10.1126/scitranslmed.3006034)
Cameron BJ, Gerry AB, Dukes J, Harper JV, Kannan V, Bianchi FC, Grand F, Brewer JE, Gupta M, Plesa G, Bossi G, Vuidepot A, Powlesland AS, Legg A, Adams KJ, Bennett AD, Pumphrey NJ, Williams DD, Binder-Scholl G, Kulikovskaya I, Levine BL, Riley JL, Varela-Rohena A, Stadtmauer EA, Rapoport AP, Linette GP, June CH, Hassan NJ, Kalos M, Jakobsen BK. Sci Transl Med. 2013 Aug 7;5(197):197ra103  

^2^ [Affinity-enhanced T-cell receptors for adoptive T-cell therapy targeting MAGE-A10: strategy for selection of an optimal candidate](https://doi.org/10.1080/2162402x.2018.1532759)
Border EC, Sanderson JP, Weissensteiner T, Gerry AB, Pumphrey NJ. Oncoimmunology. 2018 Nov 20;8(2):e1532759  

^3^ [A systematic safety pipeline for selection of T-cell receptors to enter clinical use]((https://doi.org/10.1038/s41541-023-00713-y))
Foldvari Z, Knetter C, Yang W, Gjerdingen TJ, Bollineni RC, Tran TT, Lund-Johansen F, Kolstad A, Drousch K, Klopfleisch R, Leisegang M, Olweus J.NPJ Vaccines. 2023 Aug 22;8(1):126  

^4^ [Preclinical Studies of the Off-Target Reactivity of AFP(158)-Specific TCR Engineered T Cells](https://doi.org/10.3389/fimmu.2020.00607)
Cai L, Caraballo Galva LD, Peng Y, Luo X, Zhu W, Yao Y, Ji Y, He Y.Front Immunol. 2020 Apr 27;11:607  

^5^ PlotDigitizer, 3.1.5, 2024, https://plotdigitizer.com

^6^ [Introduction to Bioinformatics](https://scholar.google.com/scholar_lookup?title=Introduction%20to%20Bioinformatics&author=A.%20Lesk&publication_year=2013&book=Introduction%20to%20Bioinformatics)  
Lesk A. Oxford University Press. 4th ed. 2014. ISBN-13 978-0199651566  


TCR Fingerprinting and Off-Target Peptide Identification.
Karapetyan AR, Chaipan C, Winkelbach K, Wimberger S, Jeong JS, Joshi B, Stein RB, Underwood D, Castle JC, van Dijk M, Seibert V. Front Immunol. 2019 Oct 22;10:2501. doi: 10.3389/fimmu.2019.02501

PepSim: T-cell cross-reactivity prediction via comparison of peptide sequence and peptide-HLA structure.
Hall-Swan S, Slone J, Rigo MM, Antunes DA, Lizée G, Kavraki LE. Front Immunol. 2023 Apr 28;14:1108303. doi: 10.3389/fimmu.2023.1108303



Preclinical Strategies to Identify Off-Target Toxicity of High-Affinity TCRs.
Bijen HM, van der Steen DM, Hagedoorn RS, Wouters AK, Wooldridge L, Falkenburg JHF, Heemskerk MHM. Mol Ther. 2018 May 2;26(5):1206-1214. doi: 10.1016/j.ymthe.2018.02.017.

Structural insights into engineering a T-cell receptor targeting MAGE-A10 with higher affinity and specificity for cancer immunotherapy.
Simister PC, Border EC, Vieira JF, Pumphrey NJ. J Immunother Cancer. 2022 Jul;10(7):e004600. doi: 10.1136/jitc-2022-004600





